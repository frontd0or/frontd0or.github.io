<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>frontd0or is locked...</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #000;
      color: #00ffcc;
      font-family: 'Share Tech Mono', monospace;
      margin: 0;
      padding: 1rem;
    }
    .terminal {
      max-width: 800px;
      margin: 0 auto;
      padding: 1rem;
      background-color: #111;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
      min-height: 80vh;
      position: relative;
      overflow: hidden;
    }
    #terminal-output {
      max-height: 60vh;
      overflow-y: auto;
      padding-bottom: 1rem;
      white-space: pre-wrap;
    }
    #terminal input {
      background: transparent;
      border: none;
      color: #00ffcc;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1rem;
      width: 90%;
      outline: none;
    }
    code {
      color: #ff003c;
    }
    .glitch {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      mix-blend-mode: difference;
      pointer-events: none;
      animation: glitchAnim 1s infinite;
      opacity: 0;
    }
    @keyframes glitchAnim {
      0%, 100% { opacity: 0; }
      10% { opacity: 0.1; transform: translateX(-5px); }
      20% { opacity: 0.2; transform: translateX(5px); }
      30% { opacity: 0; transform: none; }
    }
  </style>
</head>
<body>
  <div class="terminal" id="terminal" onclick="focusInput()">
    <div class="glitch" id="glitch-layer"></div>
    <div id="terminal-output">
<pre style="color:#ff003c;">
███████╗██████╗ ██╗   ██╗ ██████╗ ██████╗ ███████╗
██╔════╝██╔══██╗██║   ██║██╔════╝ ██╔══██╗██╔════╝
███████╗██████╔╝██║   ██║██║  ███╗██████╔╝█████╗  
╚════██║██╔═══╝ ██║   ██║██║   ██║██╔═══╝ ██╔══╝  
███████║██║     ╚██████╔╝╚██████╔╝██║     ███████╗
╚══════╝╚═╝      ╚═════╝  ╚═════╝ ╚═╝     ╚══════╝</pre>
      <div>Type <code>help</code> to begin.</div>
      <br>
    </div>
    <div>
      <span style="color:#00ffcc;" id="terminal-path">user@darkhost:~$</span>
      <input id="terminal-input" autofocus autocomplete="off" />
    </div>
  </div>

  <audio id="glitch-sound" src="media/glitch.mp3" preload="auto"></audio>
  <audio id="ambient-music" src="media/ambient.mp3" loop preload="auto"></audio>

  <script>
    const terminalInput = document.getElementById('terminal-input');
    const terminalOutput = document.getElementById('terminal-output');
    const terminalPath = document.getElementById('terminal-path');
    const glitchLayer = document.getElementById('glitch-layer');
    const glitchSound = document.getElementById('glitch-sound');
    const ambientMusic = document.getElementById('ambient-music');

    const fileSystem = {
      '/': {
        'readme.txt': `Welcome, agent.\nYour access key is hidden inside the vault.\nBut the vault is locked...`,
        'vault': {
          'vault.key': 'ACCESS_KEY: 7h15-15-f4k3-k3y',
          'locked.mp4': '<video width="320" controls><source src="media/locked.mp4" type="video/mp4">Video unsupported.</video>',
          'message.enc': 'U2VjcmV0IENvZGU6IFRoZSBwYXNzd29yZCBpcyAiRGVjb2RlVGhpcyIg',
        },
        'access.log': '',
      },
      '/deep_vault': {
        'clue.txt': 'You found the deep vault. But it only opens when you believe.',
        'confession.ogg': '[DATA MISSING]'
      }
    };

    let currentPath = '/';
    let history = [];
    let historyIndex = 0;
    let hasAccess = false;
    let deepUnlocked = false;
    let hackTimer;

    function getDir(path) {
      const parts = path.split('/').filter(Boolean);
      let dir = fileSystem['/'];
      for (const part of parts) {
        dir = dir[part];
      }
      return dir;
    }

    function updatePrompt() {
      terminalPath.textContent = `user@darkhost:${currentPath}$`;
    }

    function logAccess(input) {
      const log = getDir('/');
      log['access.log'] += `[${new Date().toISOString()}] ${input}\n`;
    }

    function resolveCommand(input) {
      const args = input.split(' ');
      const cmd = args[0];
      logAccess(input);

      switch (cmd) {
        case 'help':
          return `Commands: help, ls, cd, cat, clear, exit, access <key>, unlock --deep, decode <file>, hack, mute, unmute`;

        case 'ls': {
          const dir = getDir(currentPath);
          return Object.keys(dir).join('  ');
        }

        case 'cd': {
          const target = args[1];
          if (!target) return 'cd what?';
          if (target === '..') {
            if (currentPath !== '/') {
              currentPath = currentPath.split('/').slice(0, -1).join('/') || '/';
            }
            updatePrompt();
            return '';
          }
          const dir = getDir(currentPath);
          if (dir[target] && typeof dir[target] === 'object') {
            currentPath += (currentPath === '/' ? '' : '/') + target;
            updatePrompt();
            return '';
          }
          return `No such directory: ${target}`;
        }

        case 'cat': {
          const file = args[1];
          const dir = getDir(currentPath);
          if (!dir[file]) return `No such file: ${file}`;
          if (typeof dir[file] === 'object') return `${file} is a directory.`;
          return dir[file];
        }

        case 'access': {
          const key = args[1];
          if (key === '7h15-15-f4k3-k3y') {
            hasAccess = true;
            triggerGlitch();
            glitchSound.play();
            return '> Access granted. Welcome back, operative.';
          } else {
            return 'Access denied.';
          }
        }

        case 'unlock': {
          if (args[1] === '--deep' && hasAccess) {
            deepUnlocked = true;
            fileSystem['/']['deep_vault'] = fileSystem['/deep_vault'];
            return 'Deep vault unlocked.';
          } else {
            return 'Permission denied or key not authenticated.';
          }
        }

        case 'decode': {
          const file = args[1];
          const dir = getDir(currentPath);
          if (!dir[file]) return `No such file: ${file}`;
          try {
            return atob(dir[file]);
          } catch {
            return 'Decoding failed.';
          }
        }

        case 'hack': {
          startHackTimer();
          return 'HACK MODE ENABLED. Enter password before time runs out...';
        }

        case 'clear':
          return 'clear';

        case 'exit':
          return 'Session terminated.';

        case 'mute':
          ambientMusic.pause();
          return 'Audio muted.';

        case 'unmute':
          ambientMusic.play();
          return 'Audio unmuted.';

        default:
          if (input === 'DecodeThis') {
            clearTimeout(hackTimer);
            return '>> Hack successful. System override complete.';
          }
          return `'${cmd}' is not recognized. Try 'help'.`;
      }
    }

    terminalInput.addEventListener('keydown', async function (e) {
      if (e.key === 'Enter') {
        const input = terminalInput.value.trim();
        if (!input) return;

        history.push(input);
        historyIndex = history.length;

        addOutput(`user@darkhost:${currentPath}$ ${input}`);
        const result = resolveCommand(input);

        if (result === 'clear') {
          terminalOutput.innerHTML = '';
        } else {
          await typeOutput(result);
        }

        terminalInput.value = '';
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') {
        if (historyIndex > 0) {
          historyIndex--;
          terminalInput.value = history[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          terminalInput.value = history[historyIndex];
        } else {
          terminalInput.value = '';
        }
      }
    });

    function addOutput(text) {
      const line = document.createElement('div');
      line.innerHTML = text;
      terminalOutput.appendChild(line);
      terminalOutput.scrollTop = terminalOutput.scrollHeight;
    }

    async function typeOutput(text) {
      const line = document.createElement('div');
      terminalOutput.appendChild(line);
      for (let char of text) {
        line.innerHTML += char;
        await new Promise(res => setTimeout(res, 10));
      }
      terminalOutput.appendChild(document.createElement('br'));
      terminalOutput.scrollTop = terminalOutput.scrollHeight;
    }

    function triggerGlitch() {
      glitchLayer.style.opacity = '1';
      setTimeout(() => {
        glitchLayer.style.opacity = '0';
      }, 500);
    }

    function startHackTimer() {
      clearTimeout(hackTimer);
      hackTimer = setTimeout(() => {
        addOutput('>>> Time expired. System lockdown engaged.');
      }, 60000);
    }

    function focusInput() {
      terminalInput.focus();
    }

    window.onload = () => {
      focusInput();
      updatePrompt();
      ambientMusic.volume = 0.3;
      ambientMusic.play().catch(() => {});
    };
  </script>
</body>
</html>
